import uuid

from tornado import web


class Recorder(web.Application):
    """Imbues an application with recording abilities."""

    def __init__(self, *args, **kwargs):
        super(Recorder, self).__init__(*args, **kwargs)

    def set_divak_service(self, service_name):
        """
        Set the name of the service for reporting purposes.

        :param str service_name: name to use when reporting to an
            observer

        """

    def add_divak_propagator(self, propagator):
        """
        Add a propagation instance that inspects each request.

        :param propagator: a propagator instance to inspect requests
            and potentially modify responses

        """
        propagator.install(self)

    def add_divak_reporter(self, reporter):
        """
        Add a reporter instance.

        :param reporter: a reporter instance to receive observations

        """


class AlwaysSampleSampler(object):
    pass


class RequestTracker(object):
    pass


class NullReporter(object):
    """Reporter that does nothing."""


class RequestIdPropagator(object):
    """
    Propagates Request-IDs between services.

    :param str header_name: the name of the request header to propagate.
        If this value is unspecified, then the header name defaults to
        ``Request-ID``.
    :keyword value_factory: if this keyword is specified, then it's value
        is called to generate a response header if a new header value is
        required.  If this value is unspecified, then a UUID4 will be
        generated.

    This class implements propagation of a request header into the
    response.  If the incoming request does not include a matching header,
    then a new value will be generated by calling `value_factory`.  You
    can disable the generation of new values by setting `value_factory`
    to :data:`None`.

    """

    def __init__(self, header_name='Request-Id', *args, **kwargs):
        super(RequestIdPropagator, self).__init__()
        self._header_name = header_name
        self._value_factory = kwargs.get('value_factory', uuid.uuid4)

    def install(self, application):
        """
        Install the propagator into the application.

        :param tornado.web.Application application: the application
            to install this propagator into
        :returns: :data:`True` if the propagator wants to be called
            in the future or :data:`False` otherwise
        :rtype: bool

        """
        application.add_transform(HeaderRelayTransformer(self._header_name,
                                                         self._value_factory))
        return False


class HeaderRelayTransformer(object):
    """
    Tornado transformer that relays a header from request to response.

    :param str header_name: the name of the header to relay from
        request to response
    :param value_factory: callable that generates a new value

    Setting `value_factory` to :data:`None` disables the generation
    of response header values when the header is missing from the
    request.

    This class implements the under-documented Tornado transform
    interface.  Transforms are called when the application starts
    processing a request.  The ``__call__`` method can return a
    object that is used to process outgoing chunks.  This class
    implements :meth:`.__call__` to return ``self`` so that the
    :meth:`transform_first_chunk` and :meth:`transform_chunk`
    methods are called to process outgoing data.

    """

    def __init__(self, header_name, value_factory):
        super(HeaderRelayTransformer, self).__init__()
        self._header_name = header_name
        self._value_factory = value_factory
        self._header_value = None

    def __call__(self, request):
        """
        Start processing `request` and set up future processing.

        :param tornado.httputil.HTTPServerRequest request: the request
            that is being processed
        :return: an instance that defines `transform_first_chunk` and
            `transform_chunk` methods

        This method returns a transformer that will be called to transform
        outgoing body chunks.  In this case, we simply return `self`.  The
        :meth:`.transform_first_chunk` and :meth:`.transform_chunk` methods
        will be called as chunks are written by the request handler.

        """
        self._header_value = request.headers.get(self._header_name, None)
        return self

    def transform_first_chunk(self, status_code, headers, chunk,
                              include_footers):
        """
        Called to process the first chunk.

        :param int status_code: status code that is going to be
            returned in the response
        :param tornado.httputil.HTTPHeaders headers: response headers
        :param chunk: the data chunk to transform
        :param bool include_footers: should footers be included?
        :return: the status code, headers, and chunk to use as a tuple

        This method may inject a response header into `headers`.  The
        remaining parameters are passed through as-is.

        """
        if self._header_value is None and self._value_factory is not None:
            self._header_value = str(self._value_factory())
        if self._header_value is not None:
            headers.setdefault(self._header_name, self._header_value)
        return status_code, headers, chunk

    def transform_chunk(self, chunk, include_footers):
        """
        Called to transform subsequent chunks.

        :param chunk: the data chunk to transform
        :param bool include_footers: should footers be included?
        :return: the possibly transformed chunk

        This implementation returns `chunk` as-is.

        """
        return chunk
